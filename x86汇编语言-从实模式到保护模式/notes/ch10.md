# 第 10 章 32 位 Intel 微处理器编程架构

**新知识，总是让人十分激动的**

所谓处理器架构，或者处理器编程架构，是指一整套的硬件结构，以及与之相适应的工作状态

Intel 32 位处理器架构简称 IA-32（Intel Architecture，32-bit），是以 1978 年的 8086 处理器为基础发展起来的。

8086 有 20 根地址线，可以寻址 1MB 内存。但是，它内部的寄存器是16 位的，无法在程序中访问整个 1MB 内存。所以，它也是第一款支持内存分段模型的处理器。还有，8086 处理器只有一种工作模式，即实模式。

## 10.1 IA-32 架构的基本执行环境

### 10.1.1 寄存器的扩展

在 16 位处理器内，有 8 个通用寄存器 AX、BX、CX、DX、SI、DI、BP 和 SP，其中，前 4 个还可以拆分成两个独立的 8 位寄存器来用，即 AH、AL、BH、BL、CH、CL、DH 和DL。

32 位处理器在 16 位处理器的基础上，扩展了这 8 个通用寄存器的长度，

![image-20210125201402139](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210125201402139.png)

为了在汇编语言程序中使用经过扩展（**Extend**）的寄存器

需要给它们命名，它们的名字分别是 EAX、EBX、ECX、EDX、ESI、EDI、ESP 和 EBP。

可以在程序中使用这些寄存器，即使是在实模式下：

```assembly
mov eax,0xf0000005
mov ecx,eax
add edx,ecx
```



**指令的源操作数和目的操作数必须具有相同的长度**，个别特殊用途的指令除外。

如果目的操作数是 32 位寄存器，源操作数是立即数，那么，立即数被视为 32 位的：

```assembly
mov eax,0xf5 ;EAX←0x000000f5
```

32 位通用寄存器的高 16 位是不可独立使用的，但低 16 位保持同 16 位处理器的兼容性。因此，在任何时候它们都可以照往常一样使用：

```assembly
mov ah,0x02
mov al,0x03
add ax,si
```

可以在 32 位处理器上运行 16 位处理器上的软件。但是，它并不是 16 位处理器的简单增强。

事实上，32 位处理器有自己的 32 位工作模式-------- 32 位保护模式。

在这种模式下，可以完全、充分地发挥处理器的性能。同时，在这种模式下，处理器可以使用它全部的 32根地址线，能够访问 4GB 内存。

在 32 位模式下，为了生成 32 位物理地址，处理器需要使用 32 位的指令指针寄存器。为此，32 位处理器扩展了 IP，使之达到 32 位，即 EIP。当它工作在 16 位模式下时，依然使用 16 位的 IP；工作在 32 位模式下时，使用的是全部的 32 位 EIP。和往常一样，即使是在 32 位模式下，EIP 寄存器也只由处理器内部使用，程序中是无法直接访问的。对 IP 和 EIP 的修改通常是用某些指令隐式进行的，这此指令包括 JMP、CALL、RET 和 IRET 等等。

![image-20210125201843452](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210125201843452.png)

​															图 10-2 32 位处理器的指令指针、标志和段寄存器

另外，在 16 位处理器中，标志寄存器 FLAGS 是 16 位的，在 32 位处理器中，扩展到了 32 位 EFLAGS，**低 16 位和原先保持一致。**

在 32 位模式下，对内存的访问从理论上来说不再需要分段，因为它有 32 根地址线，可以自由访问任何一个内存位置。但是，IA-32 架构的处理器是基于分段模型的，因此，32 位处理器依然需要以段为单位访问内存，即使它工作在 32 位模式下。

不过，它也提供了一种变通的方案，即，只分一个段，段的基地址是 0x00000000，段的长度（大小）是 4GB。在这种情况下，可以视为不分段，即**平坦模型**（Flat Mode）。



每个程序都有属于自己的内存空间。在 16 位模式下，一个程序可以自由地访问不属于它的内存位置，甚至可以对那些地方的内容进行修改。这当然是不安全的，也不合法，但却没有任何机制来限制这种行为。在 32 位模式下，处理器要求在加载程序时，**先定义该程序所拥有的段，然后允许使用这些段**。定义段时，除了基地址（起始地址）外，还附加了段界限、特权级别、类型等属性。当程序访问一个段时，处理器将用固件实施各种检查工作，以防止对内存的违规访问。



如图 10-2 所示，在 32 位模式下，传统的段寄存器，如 CS、SS、DS、ES，保存的不再是 16位段基地址，而是段的**选择子**，即，用于选择所要访问的段，因此，严格地说，它的新名字叫做**段选择器**。除了段选择器之外，每个段寄存器还包括一个 64 位的不可见部分**，称为描述符高速缓存器**，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。

32 位处理器增加了两个额外的段寄存器 FS 和 GS



### 10.1.2 基本的工作模式

1982 年的时候，Intel 公司推出了 80286 处理器。这也是一款 16 位的处理器，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。

80286 处理器访问内存时，不再需要将段地址左移，因为在段寄存器的描述符高速缓存器中有 24 位的段物理基地址。这样一来，段可以位于 16MB 内存空间中的任何位置，而不再限于低端 1MB 范围内，也不必非得是位于 16 字节对齐的地方。不过，由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16位保护模式很少为人所知的原因。



1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。

和 8086/80286 不同，80386 处理器的寄存器是 32 位，而且拥有 32 根地址线，可以访问 2^32^，即 4GB 的内存。



在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。



除了保护模式，32 位处理器还提供虚拟 8086 模式（V86 模式），在这种模式下，IA-32 处理器被模拟成多个 8086 处理器并行工作。V86 模式是保护模式的一种，可以在保护模式下执行多个 8086 程序。传统上，要执行 8086 程序，处理器必须工作在实模式下。在这种情况下，为 32 位保护模式写的程序就不能运行。但是，V86 模式提供了让它们在一起同时运行的条件。现在，这种工作模式已经**基本无用**了。



### 10.1.3 线性地址

为 IA-32 处理器编程，访问内存时，需要在程序中给出段地址和偏移量，因为分段是 IA-32架构的基本特征之一。传统上，段地址和偏移地址称为逻辑地址，偏移地址叫做有效地址（Effective Address，EA），在指令中给出有效地址的方式叫做寻址方式（Addressing Mode）。
比如：

`inc word [bx+si+0x06]`

在这里，指令中使用的是基址加变址的方式来寻找最终的操作数。

段的管理是由处理器的段部件负责进行的，段部件将段地址和偏移地址相加，得到访问内存的地址。一般来说，段部件产生的地址就是物理地址。



IA-32 处理器支持多任务。在多任务环境下，任务的创建需要分配内存空间；当任务终止后，还要回收它所占用的内存空间。**在分段模型下，内存的分配是不定长的**，程序大时，就分配一大块内存；程序小时，就分配一小块。时间长了，内存空间就会碎片化，就有可能出现一种情况：内存空间是有的，但都是小块，无法分配给某个任务。为了解决这个问题，IA-32 处理器支持分页功能，**分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的**，一般为 4KB，通过使用页，可以简化内存管理。



如图 10-3 所示，当页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址（Linear Address），线性地址还要经页部件转换后，才是物理地址。

![image-20210125203741947](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210125203741947.png)

​																图 10-3 线性地址和线性地址空间

线性地址的概念用来描述任务的地址空间。如图 10-3 所示，IA-32 处理器上的每个任务都拥有4GB 的虚拟内存空间，这是一段长 4GB 的平坦空间，就像一段平直的线段，因此叫线性地址空间。相应地，由段部件产生的地址，就对应着线性地址空间上的每一个点，这就是线性地址。



## 10.2 现代处理器的结构和特点

### 10.2.1 流水线

早在 8086 时代，处理器就已经有了指令预取队列。当指令执行时，如果总线是空闲的（没有访问内存的操作），就可以在指令执行的同时预取指令并提前译码，这种做法是有效的，能大大加快程序的执行速度。

为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解成若干个细小的步骤，并分配给相应的单元来完成。各个单元的执行是独立的、并行的。如此一来，各个步骤的执行在时间上就会重叠起来，这种执行指令的方法就是流水线（Pipe-Line）技术。

![image-20210125204012430](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210125204012430.png)

### 10.2.2 高速缓存

影响处理器速度的另一个因素是存储器。从处理器内部向外看，它们分别是寄存器、内存和硬盘。

寄存器的速度是最快的，原因在于它使用了触发器(数逻没白学)，这是一种利用反馈原理制作的存储电路。触发器的工作速度是纳秒（ns）级别的，当然也可以用来做为内存的基本单元，即静态存储器（SRAM），缺点是成本太高，价格也不菲。所以，制作内存芯片的材料一般是电容和单个的晶体管，由于电容需要定时刷新，使得它的访问速度变得很慢，通常是几十个纳秒。因此，它也获得了一个恰当的名字：动态存储器（DRAM），我们所用的内存芯片，大部分都是 DRAM。最后，硬盘是机电设备，是机械和电子的混合体，它的速度最慢，通常在毫秒（ms）



在这种情况下，因为需要等待内存和硬盘这样的慢速设备，处理器便无法全速运行。为了缓解这一矛盾，高速缓存（Cache）技术应运而生。高速缓存是处理器与内存（DRAM）之间的一个静态存储器，容量较小，但速度可以与处理器匹配。

**高速缓存的用处源于程序在运行时所具有的局部性规律**（空间、时间）

首先，程序常常访问最近刚刚访问过的指令和数据，或者与它们相邻的指令和数据。比如，程序往往是序列化地从内存中取指令执行的，循环操作往往是执行一段固定的指令。当访问数据时，要访问的数据通常都被安排在一起；其次，一旦访问了某个数据，那么，不久之后，它可能会被再次访问。

如果要访问的内容已经在高速缓存中，那么，很好，可以用极快的速度直接从高速缓存中取得，这称为命中（Hit）；否则，称为不中（Miss）。

在不中的情况下，处理器在取得需要的内容之前必须重新装载高速缓存，而不只是直接到内存中去取那个内容。高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为不中惩罚（Miss Penalty）。



### 10.2.3乱序执行

为了实现流水线技术，需要将指令拆分成更小的可独立执行部分，即拆分成微操作（Micro-Operations），简写为μ ops。

`add eax,[mem]`

可以拆分成两个微操作，一个用于从内存中读取数据并保存到临时寄存器，另一个用于将 EAX 寄存器和临时寄存器中的数值相加。

`add [mem],eax`

可以拆分成三个微操作，一个从内存中读数据，一个执行相加的动作，第 3 个用于将相加的结果写回到内存中。

一旦将指令拆分成微操作，处理器就可以在必要的时候乱序执行（Out-Of-Order Execution）程序

```assembly
mov eax,[mem1]
shl eax,5
add eax,[mem2]
mov [mem3],eax
```

SHL(Shift Logical Left)是一个汇编指令，作用是逻辑左移指令，将目的操作数顺序左移1位或CL寄存器中指定的位数。左移一位时，操作数的最高位移入进位标志位CF，最低位补零。



这里，指令 add eax,[mem2]可以拆分为两个微操作。如此一来，在执行逻辑左移指令的同时，处理器可以提前从内存中读取 mem2 的内容。典型地，如果数据不在高速缓存中（不中），那么处理器在获取 mem1 的内容之后，会立即开始获取 mem2 的内容，与此同时，shl 指令的执行早就开始了。

将指令拆分成微操作，也可以使得堆栈的操作更有效率。考虑以下代码片断：

```assembly
push eax
call func

;push eax 指令可以拆分成两个微操作，即可以表述为以下的等价形式：

sub esp,4
mov [esp],eax
```

这就带来了一个好处，即使 EAX 寄存器的内容还没有准备好，微操作 sub esp,4 也可以执行。call 指令执行时需要在当前堆栈中保存返回地址，在以前，该操作只能等待 push eax 指令执行结束，因为它需要 ESP 的新值。感谢微操作，现在，call 指令在微操作 sub esp,4 执行结束时就可以无延迟地立即开始执行。



### 10.2.4 寄存器重命名

```assembly
mov eax,[mem1]
shl eax,3
mov [mem2],eax
mov eax,[mem3]
add eax,2
mov [mem4],eax
```

以上代码片断做了两件事，但互不相干：

将 mem1 里的内容左移 3 次（乘以 8），

并将 mem3里的内容加 2。

如果我们为最后三条指令使用不同的寄存器，那么将更明显地看出这两件事的无关性。并且，事实上，处理器实际上也是这样做的。处理器为最后三条指令使用了另一个不同的临时寄存器，因此，左移（乘法）和加法可以并行地处理。



IA-32 架构的处理器只有 8 个 32 位通用寄存器，但通常都会被我们全部派上用场（甚至还觉得不够）。因此，我们不能奢望在每个计算当中都使用新的寄存器。不过，在处理器内部，却有大量的临时寄存器可用，处理器可以重命名这些寄存器以代表一个逻辑寄存器，比如 EAX。

寄存器重命名以一种完全自动和非常简单的方式工作。每当指令写逻辑寄存器时，处理器就为那个逻辑寄存器分配一个新的临时寄存器。

```assembly
mov eax,[mem1]
mov ebx,[mem2]
add ebx,eax
shl eax,3
mov [mem3],eax
mov [mem4],ebx
```

假定现在 mem1 的内容在高速缓存里，可以立即取得，但 mem2 的内容不在高速缓存中。这意味着，左移操作可以在加法之前开始（使用临时寄存器代替 EAX）。为左移的结果使用一个新的临时寄存器，其好处是 EAX 寄存器中仍然是以前的内容，它将一直保持这个值，直到 EBX 寄存器中的内容就绪，然后同它一起做加法运算。如果没有寄存器重命名机制，左移操作将不得不等待从内存中读取 mem2 的内容到 EBX 寄存器以及加法操作完成。

在所有的操作都完成之后，那个代表 EAX 寄存器最终结果的临时寄存器的内容被写入真实的EAX 寄存器，该处理过程称为**引退（Retirement）**。

**所有通用寄存器，堆栈指针、标志、浮点寄存器，甚至段寄存器都有可能被重命名。**



### 10.2.5 分支目标预测

有很多潜在的因素会使得流水线不能达到最佳的效率。一个典型的情况是，如果遇到一条转移指令，则后面那些已经进入流水线的指令就都无效了。换句话说，我们必须清空（Flush）流水线，从要转移到的目标位置处重新取指令放入流水线。

现代处理器中，流水线操作分为很多步骤，包括取指令、译码、寄存器分配和重命名、微操作排序、执行和引退。

流水线的最大问题是代码中经常存在分支

分支预测的核心问题是，转移是发生还是不会发生。换句话说，条件转移指令的条件会不会成立。比如：

`jne branch5`

从统计学的角度来看，有些事情一旦出现，下一次还会出现的概率较大。一个典型的例子就是循环，

```assembly
xor si,si
lops:
…
cmp si,20
jnz lops
```

当 jnz 指令第一次执行时，转移一定会发生。那么，处理器就可以预测，下一次它还会转移到标号 lops 处，而不是顺序往下执行。事实上，这个预测通常是很准的。



在处理器内部，有一个小容量的高速缓存器，叫**分支目标缓存器**（Branch Target Buffer，BTB）。当处理器执行了一条分支语句后，它会在 BTB 中记录当前指令的地址、分支目标的地址，以及本次分支预测的结果。下一次，在那条转移指令实际执行前，处理器会查找 BTB，看有没有最近的转移记录。如果能找到对应的条目，则推测执行和上一次相同的分支，把该分支的指令送入流水线。

当该指令实际执行时，如果预测是失败的，那么，清空流水线，同时刷新 BTB 中的记录。这个代价较大。



## 10.3 32 位模式的指令系统

### 10.3.1 32 位处理器的寻址方式

在 16 位处理器上，指令中的操作数可以是 8 位或者 16 位的寄存器、指向 8 位或者 16 位实际操作数的 16 位内存地址，以及 8 位或 16 位的立即数。**如果指令中包含了内存地址操作数，那么，它必然是一个 16 位的段内偏移地址**，称为有效地址。通过有效地址，可以间接取得 8 位或者 16 位的实际操作数。指定有效地址可以使用基址寄存器 BX、BP，变址（索引）寄存器 SI 和 DI，同时还可以加上一个 8 位或 16 位的偏移量。比如：

```assembly
mov ax,[bx] 	;寄存器 BX 中的内容是指向 16 位实际操作数的 16 位地址
mov ax,[bx+di]	;寄存器 BX 和 DI 的内容相加，形成指向 16 位实际操作数的 16 位地址
mov al,[bx+si+0x02] 	;寄存器 BX SI 和 8 位偏移量共同形成指向 8 位实际操作数的 16 位地址。

```

如图  所示，这是 16 位处理器的内存寻址方式示意图。从图中可以看出，允许使用基址寄存器BX 或者 BP，同变址寄存器 SI 或者 DI 结合，再加上 8 位或者 16 位偏移量来寻址内存操作数。

![image-20210125211042562](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210125211042562.png)



32 位处理器兼容 16 位处理器的工作模式，可以运行传统的 16 位代码。但是，它有自己独立的32 位运行模式，而且只有在这种模式下才能发挥最高的运行效率。

在 32 位模式下，**默认使用 32 位宽度的寄存器**。

如果指令中的操作数是指向内存单元的地址，那么，该地址默认是 32 位的段内偏移地址，或者叫段内偏移量：

```assembly
mov edx,[mem] ;mem 是一个 32 位的段内偏移地址
```



这就是说，如果指令中包含了内存地址操作数，那么，它必然默认地是一个 32 位的有效地址。通过有效地址，可以间接取得 32 位的实际操作数。如图 10-6 所示，指定有效地址可以使用全部的32 位**通用寄存器**作为基址寄存器。同时，还可以再加上一个**除 ESP** 之外的 32 位**通用寄存器**作为变址寄存器。变址寄存器还允许乘以 1、2、4 或者 8 作为比例因子。最后，还允许加上一个 8 位或者32 位的偏移量。

![image-20210125211257333](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210125211257333.png)

​													图 10-6 32 位处理器的内存寻址方式

```assembly
add eax,[0x2008] 			;有效地址为 0x00002008
sub eax,[eax+0x08] 			;有效地址是 32 位的
mov ecx,[eax+ebx*8+0x02] 	;有效地址是 32 位的
;在 16 位模式下，内存寻址方式的操作数不允许使用堆栈指针寄存器 SP
;但是，在 32 位模式下，允许在内存操作数中使用堆栈指针寄存器 ESP
mov eax,[esp]	;合法的
```

### 10.3.2 操作数大小的指令前缀

Intel 处理器的指令系统比较复杂，这种复杂性来源于两个方面，一是指令的数量较多，二是寻址方式也很多。可以想象，为了组成这些众多的指令，必须有一套同样复杂的指令格式。

![image-20210125212313550](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210125212313550.png)

​																	图 10-7 IA-32 的指令格式

每一条处理器指令都可以拥有前缀，比如重复前缀（REP/REPE/ REPNE）、段超越前缀（如 ES：）、总线封锁前缀（LOCK）等。

前缀是可选的，每个前缀的长度是 1 字节，每条指令可以有 1～4 个前缀，或者不使用前缀。

每条指令可以有 1～4 个前缀，或者不使用前缀。

前缀（如果有的话）的后面是操作码部分，指示执行什么样的操作，比如传送、加法、减法、乘法、除法、移位等。根据指令的不同，操作码的长度是 1～3 字节。同时，操作码还可以用来指示操作的字长，即数据宽度为字节还是字。



操作码之后是操作数类型和寻址方式部分。这部分是可选的，简单的指令不包含这一部分，稍微复杂一点的指令，这一部分只有 1 字节；最复杂的指令，可能有 2 字节。这部分给出了指令的寻址方式，以及寄存器的类型（用的是哪个寄存器）。



指令的最后是立即数和偏移量。如果指令中使用了立即数，那么立即数就在这一部分给出；如果指令使用了带偏移量的寻址方式，如：

```assembly
mov cx,[0x2000]
mov ecx,[eax+ebx*8+0x02]
```

